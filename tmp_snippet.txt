function shouldBlockCacheReset(clickKey, sourceFileId, config, targetLang) {
    try {
        const clickEntry = firstClickTracker.get(clickKey);

        if (!clickEntry || !clickEntry.times || clickEntry.times.length < 3) {
            return false; // Not enough clicks yet
        }

        // Determine which cache type the user is using
        const bypass = config && config.bypassCache === true;
        const bypassCfg = (config && (config.bypassCacheConfig || config.tempCache)) || {};
        const bypassEnabled = bypass && (bypassCfg.enabled !== false);

        const configHash = (config && typeof config.__configHash === 'string' && config.__configHash.length > 0)
            ? config.__configHash
            : '';

        const baseCacheKey = `${sourceFileId}_${targetLang}`;

        // SAFETY CHECK 1: Check if the user is at their concurrency limit
        // If they are, don't allow the 3-click reset because re-translation would fail with rate limit error
        if (!canUserStartTranslation(configHash)) {
            log.warn(() => `[SafetyBlock] BLOCKING 3-click reset: User at concurrency limit, re-translation would fail (user: ${configHash || 'anonymous'})`);
            return true;
        }

        if (bypassEnabled && configHash) {
            // USER IS USING BYPASS CACHE
            // Only block if THIS user's bypass translation is in progress
            const userScopedKey = `${baseCacheKey}__u_${configHash}`;

            // Check BOTH translationStatus AND inFlightTranslations for maximum safety
            const status = translationStatus.get(userScopedKey);
            const inFlight = inFlightTranslations.has(userScopedKey);

            if (!status && !inFlight) {
                return false; // Not in progress, allow reset
            }

            if (status && status.inProgress) {
                log.warn(() => `[SafetyBlock] BLOCKING bypass cache reset: User's translation IN PROGRESS for ${sourceFileId}/${targetLang} (user: ${configHash})`);
                return true;
            }

            if (inFlight) {
                log.warn(() => `[SafetyBlock] BLOCKING bypass cache reset: User's translation IN-FLIGHT for ${sourceFileId}/${targetLang} (user: ${configHash})`);
                return true;
            }

        } else {
            // USER IS USING PERMANENT CACHE (shared between all users)
            // Block if ANY permanent cache translation is in progress
            const status = translationStatus.get(baseCacheKey);
            const inFlight = inFlightTranslations.has(baseCacheKey);

            if (!status && !inFlight) {
                return false; // Not in progress, allow reset
            }

            if (status && status.inProgress) {
                log.warn(() => `[SafetyBlock] BLOCKING permanent cache reset: Shared translation IN PROGRESS for ${sourceFileId}/${targetLang}`);
                return true;
            }

            if (inFlight) {
                log.warn(() => `[SafetyBlock] BLOCKING permanent cache reset: Shared translation IN-FLIGHT for ${sourceFileId}/${targetLang}`);
                return true;
            }
        }

        return false;
    } catch (e) {
        log.warn(() => '[SafetyBlock] Error checking cache reset safety:', e.message);
        return false; // On error, allow the reset to proceed
    }
}

// Security: Add security headers
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"], // Allow inline styles for HTML pages
            scriptSrc: ["'self'", "'unsafe-inline'"], // Allow inline scripts for HTML pages
            imgSrc: ["'self'", "data:"],
            // Don't upgrade insecure requests for localhost (would break HTTP logo loading)
            upgradeInsecureRequests: null,
        },
    },
    // Prevent leaking query params (like ?config= tokens) via referrers
    referrerPolicy: { policy: 'no-referrer' },
    crossOriginEmbedderPolicy: false, // Disable for Stremio compatibility
    crossOriginResourcePolicy: false, // Disable to allow Stremio to load logo/images
    strictTransportSecurity: false, // Disable HSTS for localhost (allows HTTP)
}));

// Security: Rate limiting for subtitle searches and translations
// Uses session ID or config hash instead of IP for better HA deployment support
// This prevents all users behind a load balancer from sharing the same rate limit
const searchLimiter = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: 100, // 100 requests per minute per user (increased from 20 for HA support)
    message: 'Too many subtitle requests, please try again later.',
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Try session ID first (if sessions are enabled)
        if (req.session?.id) {
            return `session:${req.session.id}`;
        }
        // Try config hash from params (most common for Stremio addons)
        if (req.params?.config) {
            try {
                return `config:${computeConfigHash(req.params.config)}`;
            } catch (e) {
                // Fall through to IP if config parsing fails
            }
        }
        // Try config from body (for API endpoints)
        if (req.body?.configStr) {
            try {
                const shouldBlock = shouldBlockCacheReset(clickKey, sourceFileId, config, targetLang);

                if (shouldBlock) {
                    log.debug(() => `[PurgeTrigger] 3 rapid loads detected but BLOCKED: Translation in progress for ${sourceFileId}/${targetLang} (user: ${config.__configHash})`);
                } else {
                    // Reset the counter immediately to avoid loops
                    firstClickTracker.set(clickKey, { times: [] });
                    const hadCache = await hasCachedTranslation(sourceFileId, targetLang, config);
                    if (hadCache) {
                        log.debug(() => `[PurgeTrigger] 3 rapid loads detected (<5s) for ${sourceFileId}/${targetLang}. Purging cache and re-triggering translation.`);
                        await purgeTranslationCache(sourceFileId, targetLang, config);
                    } else {
                        log.debug(() => `[PurgeTrigger] 3 rapid loads detected but no cached translation found for ${sourceFileId}/${targetLang}. Skipping purge.`);
                    }
                }
            }
        } catch (e) {
            log.warn(() => '[PurgeTrigger] Click tracking error:', e.message);
        }

        // Check if already in flight BEFORE logging to reduce confusion
        const isAlreadyInFlight = inFlightRequests.has(dedupKey);

        if (isAlreadyInFlight) {
            log.debug(() => `[Translation] Duplicate request detected for ${sourceFileId} to ${targetLang} - checking for partial results`);

            // Generate cache keys using shared utility (single source of truth for cache key scoping)
            const { cacheKey } = generateCacheKeys(config, sourceFileId, targetLang);

            // For duplicate requests, check partial cache FIRST (in-flight translations)
            // Both partial cache and bypass cache use the same scoped key (cacheKey)
            const partialCached = await readFromPartialCache(cacheKey);
            if (partialCached && typeof partialCached.content === 'string' && partialCached.content.length > 0) {
                log.debug(() => `[Translation] Found in-flight partial in partial cache for ${sourceFileId} (${partialCached.content.length} chars)`);
                res.setHeader('Content-Type', 'text/plain; charset=utf-8');
                res.setHeader('Cache-Control', 'no-cache, must-revalidate');
                res.setHeader('Pragma', 'no-cache');
                return res.send(partialCached.content);
            }

            // Then check bypass cache for user-controlled bypass cache behavior
            const { StorageAdapter } = require('./src/storage');
            const { getStorageAdapter } = require('./src/storage/StorageFactory');
            const adapter = await getStorageAdapter();
            const bypassCached = await adapter.get(cacheKey, StorageAdapter.CACHE_TYPES.BYPASS);
            if (bypassCached && typeof bypassCached.content === 'string' && bypassCached.content.length > 0) {
                log.debug(() => `[Translation] Found bypass cache result for ${sourceFileId} (${bypassCached.content.length} chars)`);
                res.setHeader('Content-Type', 'text/plain; charset=utf-8');
                res.setHeader('Cache-Control', 'no-cache, must-revalidate');
                res.setHeader('Pragma', 'no-cache');
                return res.send(bypassCached.content);
            }

            // No partial yet, serve loading message
            log.debug(() => `[Translation] No partial found yet, serving loading message to duplicate request for ${sourceFileId}`);
            const loadingMsg = createLoadingSubtitle();
            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.setHeader('Cache-Control', 'no-cache, must-revalidate');
            res.setHeader('Pragma', 'no-cache');
            return res.send(loadingMsg);
        } else {
            log.debug(() => `[Translation] New request to translate ${sourceFileId} to ${targetLang}`);
        }

        // Deduplicate translation requests - handles the first request
        const subtitleContent = await deduplicate(dedupKey, () =>
            handleTranslation(sourceFileId, targetLang, config)
        );

        // Validate content before processing
        if (!subtitleContent || typeof subtitleContent !== 'string') {
            log.error(() => `[Translation] Invalid subtitle content returned: ${typeof subtitleContent}, value: ${subtitleContent}`);
            return res.status(500).send('Translation returned invalid content');
        }

        // Check if this is a loading message or actual translation
        const isLoadingMessage = subtitleContent.includes('Please wait while the selected subtitle is being translated') ||
                                 subtitleContent.includes('Translation is happening in the background') ||
                                 subtitleContent.includes('Click this subtitle again to confirm translation') ||
                                 subtitleContent.includes('TRANSLATION IN PROGRESS');
        log.debug(() => `[Translation] Serving ${isLoadingMessage ? 'loading message' : 'translated content'} for ${sourceFileId} (was duplicate: ${isAlreadyInFlight})`);
        log.debug(() => `[Translation] Content length: ${subtitleContent.length} characters, first 200 chars: ${subtitleContent.substring(0, 200)}`);

        // Don't use 'attachment' for loading messages - we want them to display inline
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');

        // Disable caching for loading messages so Stremio can poll for updates
        if (isLoadingMessage) {
            res.setHeader('Cache-Control', 'no-cache, must-revalidate');
            res.setHeader('Pragma', 'no-cache');
            log.debug(() => `[Translation] Set no-cache headers for loading message`);
        } else {
            res.setHeader('Content-Disposition', `attachment; filename="translated_${targetLang}.srt"`);
        }

        res.send(subtitleContent);
        log.debug(() => `[Translation] Response sent successfully for ${sourceFileId}`);

    } catch (error) {
        log.error(() => '[Translation] Error:', error);
        res.status(500).send(`Translation failed: ${error.message}`);
    }
});

// Custom route: File translation page (BEFORE SDK router to take precedence)
app.get('/addon/:config/file-translate/:videoId', async (req, res) => {
    try {
        const { config: configStr, videoId } = req.params;
        const config = await resolveConfigAsync(configStr, req);

        log.debug(() => `[File Translation] Request for video ${videoId}`);

        // Redirect to the actual upload page
        // Using a separate non-addon route so browser opens it directly
        res.redirect(302, `/file-upload?config=${encodeURIComponent(configStr)}&videoId=${encodeURIComponent(videoId)}`);

    } catch (error) {
        log.error(() => '[File Translation] Error:', error);
        res.status(500).send('Failed to load file translation page');
    }
});
